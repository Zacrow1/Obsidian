---
tags:
  - universidad
Profesor: " Juan Carlos Gonzalez"
p.Mail: " juan.gonzalez@jala.university"
Practitioner:
---
> [!Introducción]
> Content

```button
name University
type link
action obsidian://open?vault=NewBegin&file=Areas%2FUniversidad%2FUniversidad%20Index
```

### TEMAS
[[Introducción a la gestión de la ingeniería de software]]
[[Git]]
[[Casos de uso]]

---
# Semanas
## Semana 1 

### [[Introducción a la gestión de la ingeniería de software]]

#### FORO
El control de versiones, más allá de su uso en software, te permite registrar y recuperar versiones anteriores de casi cualquier archivo
Tiene ventajas como el seguimiento de cambios y control del historial:
- Registran cada modificación realizada a los archivos, permitiendo rastrear quién hizo qué y cuándo.
- Facilitan la reversión a versiones anteriores en caso de errores o la necesidad de cambios.
2. Colaboración eficiente:
- Permiten que múltiples usuarios trabajen en el mismo proyecto simultáneamente sin conflictos.
- Facilitan la fusión de cambios realizados por diferentes personas.
3. Reproducibilidad:
- Garantizan que cualquier persona pueda obtener una copia exacta de cualquier versión anterior del proyecto.
- Simplifican la implementación de nuevas funciones o la corrección de errores, ya que es posible volver a un estado anterior que se sabe que funciona.
- Aportan confiabilidad al proyecto, ya que se puede restaurar a un estado estable en caso de problemas.
5. Mejor organización y eficiencia:
- Ayudan a mantener el proyecto organizado y estructurado, facilitando la búsqueda y gestión de archivos.
- Optimizan el flujo de trabajo del equipo, aumentando la productividad y la eficiencia.

 A golpea B, quien por inercia golpea C haciendo sonar asustando D quien huye a E, D tiene atado F quien activa G que agujerea H que llena I, J empuja K que tira a L a M, M corre activa O, que se llena P, que hace girar Q que tira R para que se abra el portón

Algunos errores puede ser que D corra para otro lado, que muerda F y escape, que G se atore, que L vuele, que M se vaya

Con la tecnologia actual podriamos poner un sensor que lea la patente del coche para mediante una señal envie al motor que esta conectado a una tuerca que gira para mover el porton

#### TAREA

#### LABORATORIO


---
## Semana 2 

### ## **Ingeniería de Requerimientos**
[[Componentes de la ingenieria de requerimientos]]
[[Requisitos e Historias de usuarios]]

#### FORO
 Problemática clase 2
La problemática principal es que debido a las huelgas del Servicio nacional de ingles varias personas han tenido una demora significativa mayor a lo estipulado por el objetivo de la sanidad publica poniendo en riesgo la situación del paciente en riego incluso generando una defunción. Babu-Narayan indico la falta de mano de obra y las difíciles condiciones de trabajo incluso la falta de instalaciones adecuadas, definiendo finalmente la falta de presupuesto del mismo.

Algunas soluciones posibles serian: Destinar mas ingresos para mejorar las instalaciones, aumentar los sueldos y poder contratar mayor mano de obra así como alivianar la carga de trabajo de los médicos y enfermeros que ya se encuentran desbordados de pacientes. Mejorar la comunicacion entre el Servicio nacional ingles y los trabajadores de la salud.

---
Para tener una gestión eficaz de cambios en los requisitos sin interrumpir el desarrollo se pueden definir los pasos para solicitar, evaluar, aprobar e implementar cambios en los requisitos. Designando equipos responsables de la gestión de cambios, la comunicación y la toma de decisiones. A su vez es importante tener un diseño flexible y adaptable.

Para asegurar la comunicación con los stakeholders es necesario documentar los requisitos de manera clara y concisa utilizando un lenguaje sencillo y comprensible para todos los stakeholders. Utilizar herramientas visuales para comunicar los cambios de manera efectiva.
Fomentar la retroalimentación continua para garantizar que los requisitos modificados se comprendan correctamente.

#### TAREA

#### LABORATORIO


---
## Semana 3 
[[Lean SDLC]]
[[Scrum]]
[[Kanban]]
[[Prince2]] (gestion de proyecto)
[[Pmbok]] (gestion de proyecto)

### ¿Qué son las Metodologías Agiles?
es una metodología iterativa, es decir, se realizan entregas cíclicas y en cada entrega se realizan todas las fases del ciclo: desde toma de requerimientos, diseño, verificación y entrega. En los procesos ágiles se entrega valor constantemente y se recibe feedback también durante todo el proyecto.

Las metodologías ágiles son estructuras de trabajo para la gestión de proyectos en las que los proyectos se dividen en muchas fases dinámicas, normalmente conocidas como “sprints”. Después de cada sprint, los equipos reflexionan y observan lo que ha sucedido. Evalúan si hay algo que se podría mejorar para poder ajustar la estrategia para el siguiente sprint.
- Comprender el problema y cómo dividir el trabajo
- Planificación de Sprint en Scrum
- Reuniones diarias de Scrum

#### ¿Como surge?

- Requerimientos fuera de control
- No cumplimiento de los tiempos planificados (desvíos)
- Estimaciones deficientes
- Re trabajo excesivo
- Baja calidad
- Costos excedidos
- Insatisfacción del Cliente
- Insatisfacción de los profesionales participantes

![[Pasted image 20240513181533.png]]

En el año 2001 en estados unidos tuvo lugar la reunión en donde 17 de los mejores críticos de los modelos de mejora del desarrollo de software los cuales fueron convocados a su vez
por Kent Beck ingeniero estadounidense, quien años atrás se había constituido en uno de los progenitores de las metodologías de desarrollo de software.
Consecuentemente los integrantes de esta reunión sintetizaron una serie de principios de toda metodología ágil como una comunicación directa con el cliente, gente altamente motivada en una serie de 12 principios que a su vez se resumen en 4 postulados los cuales se han nominado como Metodología Ágil.

![[Pasted image 20240513181730.png]]

![[Pasted image 20240513181813.png]]

### ¿Cuando un metodo es ágil?
Simple pero duro. No se basa en el seguimiento de un plan sino en la adaptación continua a la evolución del proyecto. El desarrollo de software es:

- Incremental
	liberaciones pequeñas y ciclos rápidos.
- Cooperativo
	clientes y desarrolladores trabajando juntos.
- Simple y Directo
	el método es fácil de aprender y modificar.
- Adaptativo
	es posible realizar cambios de último momento.


| Metodologías Agiles                                                                | Metodologías Tradicionales                                                       |
| ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| Basadas en heurísticas provenientes  <br>de prácticas de producción de  <br>código | Basadas en normas provenientes  <br>de estándares                                |
| Especialmente preparados para  <br>cambios durante el proyecto                     | Seguidos por el entorno de  <br>desarrollo                                       |
| Impuestas internamente (por el  <br>equipo)                                        | Cierta resistencia a los cambios                                                 |
| Proceso mucho más controlado, con  <br>numerosas políticas/normas                  | Impuestas externamente                                                           |
| No existe contrato tradicional o al  <br>menos es bastante flexible                | Proceso menos controlado, con  <br>pocos principios                              |
| El cliente interactúa con el equipo de  <br>desarrollo                             | Existe un contrato prefijado                                                     |
| Grupos pequeños (<10 integrantes)  <br>y trabajando en el mismo sitio              | El cliente es parte del equipo de  <br>desarrollo mediante reuniones             |
| Pocos artefactos                                                                   | Grupos grandes y posiblemente  <br>distribuidos                                  |
| Pocos roles                                                                        | Más artefactos                                                                   |
| Menos énfasis en la arquitectura del  <br>software                                 | Más roles                                                                        |
|                                                                                    | La arquitectura del software es  <br>esencial y se expresa mediante  <br>modelos |
![[Pasted image 20240513183825.png]]

![[Pasted image 20240515184405.png]]

#### FORO
 
#### TAREA

#### LABORATORIO


---
## Semana 4

### Estimación Ágil
Valor de negocio
El campo «valor» de una historia de usuario representa el valor de negocio
que aportará una vez realizada.
Aporta información más profunda que la razón de la historia, pues está ligado a la lógica del negocio. Una manera de estimarlo es considerar cuánto estaría diespuesto a pagar el cliente por la funcionalidad.
Esta propuesta tiene dos efectos secundarios muy interesantes: fomentar el respeto y comprensión del equipo hacia el propietario del producto y que éste comprenda mejor por qué el equipo necesita a veces reestimar ciertas historias.
Es muy importante conocer el valor de negocio para priorizar correctamente y focalizar al equipo. También existen otros factores a tener en cuenta, por lo que valor y prioridad son dos informaciones independientes.

El valor se mide con una escala arbitraria y normalmente numérica. Ha de ser una con la que el propietario del producto y los usuarios se sientan cómodos, por ejemplo, la serie de Fibonacci, o series de números naturales corno del I al 10, del I al 100 0 del I a 1.000.000.
Benoit Pointet y Thomas Botton proponen estimar el valor de la misma manera que el equipo estima el esfuerzo, mediante cartas de planning poker con la serie de Fibonacci. El valor, igual que el esfuerzo, es sumativo y relativo entre historias.
La idea es que el propietario del producto y los expertos de negocio se reúnan para estimar el valor de las historias mediante planning poker, creando una base de conocimiento compartida para usuarios y gente del negocio. De la misma manera que se crea una base común en las reuniones del equipo.

![[Pasted image 20240520175743.png]]

![[Pasted image 20240520181051.png]]



Método MoSCoW Es un acrónimo del inglés para definir los cuatro niveles de prioridad que las Historias de Usuario deben tener de acuerdo con lo siguiente:

- Must have, es necesario: la funcionalidad debe estar implementada en la solución, si no ésta fallará o no podrá considerarse un éxito.
- Shmald have, es recomendable: se debería implementar, ya que es ura funcionalidad de alta prioridad. La solución no fallará si ro existe, pero haber causas justificadas.
- Could have, podría es deseable, sería conveniente tener esta funcionalidad en la solución, pero dependerá de los tiempos y el presupuesto del proyecto.
- Wont have, no lo por ahora: se trata de una funcionalidad de muy baja prioridad o descartada, pero que en el futuro puede ser relevante. En tal pasaría a alguno de los otros estados.

Es importante distinguir entre prioridad y valor. Puede que una historia de usuario no tenga
ningún valor para el cliente o usuario, pero que esta sea imprescindible y de alta prioridad. Un caso sería la infraestructura necesaria para la implementación de un software, que ro aporta valor al cliente en sí, pero sin Ia cual no se puede desarrollar ni ejecutar la solución.

![[Pasted image 20240520184001.png]]
![[Pasted image 20240520184015.png]]

**I = Independiente**
**N = Negociable**
**V  = Valor**
**E = Estimación/Prioridad**
**S = Small/ Tarea pequeña**
**T = Testeable** 



#### FORO

> [!QUESTION]
> ¿Por qué es crucial la estimación ágil en el desarrollo de software? ¿Cómo impacta en la planificación y entrega del proyecto? ¿Por qué es importante medir y optimizar el Cycle Time en proyectos ágiles?

Las estimaciones ágiles brindan una comprensión clara del alcance y la complejidad del proyecto, esto facilita la planificación efectiva, la asignación de recursos y la toma de decisiones informadas. A su vez fomenta la colaboración y la comunicación entre los interesados para identificar y abordar problemas potenciales de manera temprana, evitando retrasos y costos adicionales. También permiten al equipo adaptarse a estos cambios de manera flexible, ajustando las prioridades y reasignando recursos según sea necesario.

El Cycle Time es una métrica clave en el desarrollo ágil que mide el tiempo que tarda un equipo en completar una funcionalidad o una característica, desde el inicio del trabajo hasta su entrega al cliente. Son importantes para los equipos porque pueden identificar los puntos del proceso que ralentizan el desarrollo. Sirve para fomentar la adopción de prácticas de entrega continua, donde el software se libera en pequeñas iteraciones frecuentes, lo que permite recibir comentarios tempranos y mejorar la calidad general del producto.
#### TAREA

#### LABORATORIO
Sprint 1

---
## Semana 5

### Casos de uso

#### FORO

> [!Question]
> - ¿Cuál es la principal diferencia entre los casos de uso y las historias de usuario?
> - ¿En qué nos ayudan los casos de uso en el proceso de desarrollo de software?

La principal diferencia entre una historia de usuario y los casos de uso es que los casos de uso pueden incluir un diagrama de flujo, además se pueden especificar las condiciones de error y las historias de usuario suele ser una narrativa por lo general en forma de tarjeta.

La importancia de los casos de uso esta en que se diseña el sistema desde el propio  
punto de vista del usuario. Analizando y diseño del sistema desde una etapa inicial para un mejor acercamiento/entendimiento del mismo.

#### TAREA

#### LABORATORIO


---
## Semana 6

### Revisión de código
![[Pasted image 20240603190349.png]]
![[Pasted image 20240603190512.png]]
![[Pasted image 20240603190558.png]]

#### FORO

> [!Question]
> ¿Por qué necesitamos la revisión de código y qué deberíamos buscar en una revisión de código?

La revisión de código nos sirve por varios motivos el primero y principal es para la detección de errores de manera temprana, como por ejemplo riegos de seguridad, a su vez una revisión de otro desarrollador nos ayuda a depurar durante el desarrollo del software, disminuyendo la cantidad de errores que "llegan" a producción o al publicar el proyecto. Tener una revisión del código también hace que el desarrollador y el/los reviewers  fomenten un código con buenas practicas que a futuro facilite que otros desarrolladores puedan comprender y modificar el mismo de ser necesario.

como reviewer deberíamos buscar o corroborar  que el código tenga un uso correcto y cumpla los requisitos especificados, un código con buenas practicas así como detectar errores ya sean de sintaxis, de lógica y/o de seguridad. En caso de encontrar alguna oportunidad de mejora/eficiencia deberíamos informarla.
#### TAREA

#### LABORATORIO


---
## Semana 7

### Métricas
[[Métricas]]

#### FORO
 
#### TAREA

#### LABORATORIO


---
## Proyecto Final
 Desarrollar un app (definida por el practitioner)
 Equipo colaborativo de X personas

MinReq.
 Codigo de calidad (en [[Java ]] con Paradigma estructurado de forma modular) o MySQL

 [[Proyecto-Final-Desarrollo-Software-1]]

# Cuadro Materia


|   Materia   |                1                 |            2            |            3            |            4            |            5            |            6            |            7            |            8            |
| :---------: | :------------------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: |
|    Foro     | <input type="checkbox" checked>  | <input type="checkbox"> "> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
|  Respuesta  | <input type="checkbox" checked>  | <input type="checkbox"> | <input type="checkbox"  | <input type="checkbo "> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
| Laboratorio |     <input type="checkbox">      | <input type="checkbox"> | <input type="checkbox"  | <input type="checkbo "> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
|    Tarea    | <input type="checkbox" checked > | <input type="checkbox"> | <input type="checkbox"  | <input type="checkbo "> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
|    Extra    |     <input type="checkbox">      | <input type="checkbox"> | <input type="checkbox"  | <input type="checkbo "> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |

# Material Complementario

![[Areas/Universidad/All things/attachments/1.2 Gestión de Configuración de Software.pdf]]
![[Ingeniería de software.pdf]]