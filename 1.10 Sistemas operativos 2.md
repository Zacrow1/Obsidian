---
tags:
  - universidad
Profesor: 
p.Mail: 
Practitioner:
---
> [!info] Introducción
> Content

```button
name University
type link
action obsidian://open?vault=NewBegin&file=Areas%2FUniversidad%2FUniversidad%20Index
```
[[Glosario SistemasOperativos]]
[[1.8 Sistemas operativos 1]]

### TEMAS
[[Concepto de sistemas distribuidos]]
[[Fundamentos de redes e Internetworking]]
[[Configuración de Sistemas]]
[[Tipos de servidores]]
[[Contenerización]] // Dockers

---
# Semanas
## Semana 1 

### Titulo

#### FORO

> [!QUESTION]
> ¿Cuál es su opinión respecto a las ventajas y desventajas de los siguientes modelos, y en qué escenarios usaría cada uno de ellos?
> - Grid computing,
> - Cluster computing,
> - Cloud computing, 
> - Client-Server,
> - Peer-to-Peer.

Hola compañeros como están?

Grid Computing: 
	Aprovecha los recursos inactivos combinando la potencia de procesamiento de múltiples computadoras, con un bajo costo, con una buena taza de escalabilidad, y facilita la colaboración. En contraparte requiere un software y herramientas especificar de gestión y coordinación de recursos, tiene una difícil integración de sistemas con diferentes arquitecturas y sistemas operativos, también es necesario implementar medidas de seguridad adecuadas para proteger datos y recursos. Suele usarse en simulaciones complejas y modelado científico.

Clúster Computing:
	Ofrece un procesamiento paralelo rápido para aplicaciones exigentes. Posee una buena escalabilidad ya que permite agregar nodos fácilmente para aumentar la potencia de cálculo. Minimiza el tiempo de inactividad al replicar datos y servicios y reduce el riesgo de fallos mediante la redundancia de componentes. Por otro lado tiene un costo elevado lo que requiere una inversión inicial significativa en hardware y software. A demás la gestión y administración de clusters puede ser compleja. Esta diseñado para aplicaciones de alto rendimiento y no es ideal para tareas generales.  Es usado para análisis de datos a gran escala y aprendizaje automático.

Cloud Computing:
	Los recursos informáticos se encuentran disponibles a través de Internet Tiene una gran escalabilidad de recursos de manera rápida y flexible según la demanda. También elimina la necesidad de grandes inversiones iniciales. Tiene una gestión remota que simplifica la administración y mantenimiento de la infraestructura. Mientras que el control sobre los datos y la infraestructura reside en el proveedor de la nube, por lo que es crucial elegir un proveedor confiable y tomar medidas para proteger los datos en la nube. Al estar en la nube requiere una conexión a internet confiable para acceder a los recursos. Los costos pueden aumentar significativamente con el uso continuo. Utilizado principalmente en implementación de aplicaciones web y móviles.

Client-Server:
	 Es fácil de implementar y administrar nos permite tener un mayor control sobre los datos y la infraestructura. Con una buena escalabilidad vertical agregando más recursos al servidor, con una amplia compatibilidad con software y hardware estándar. Las desventajas con las que cuenta son, que requiere inversión en hardware y software para el servidor, necesita mantenimiento y actualizaciones regulares. La escalabilidad horizontal es limitada, ya que requiere agregar más servidores. Es un punto único de falla, lo que genera riesgo de inactividad. Especialmente usado en aplicaciones empresariales como CRM (Customer Relationship Management), ERP (Enterprise Resource Planning) y contabilidad.

Peer-to-Peer (P2P):
	 No tiene un servidor central, lo que aumenta la resistencia a fallos y la censura, es altamente escalable, ya que la carga se distribuye entre todos los participantes. Por otro lado tiene un buen aprovechamiento de los recursos inactivos de los nodos participantes. Tiene un bajo costo ya que no requiere inversión en infraestructura centralizada.  La gestión y coordinación de la red P2P puede ser compleja. y es vulnerable a ataques de seguridad y distribución de malware, su rendimiento depende de la disponibilidad y la velocidad de los nodos participantes y puede ser utilizada para la distribución ilegal. El uso mas conocido de P2P es de intercambio de música, películas, software y otros archivos digitales.

#### TAREA

> [!help] Consignas
> Durante las clases y a medida que revise las presentaciones de la clase y el [material sugerido](https://jalauniversity.instructure.com/courses/514/pages/1-dot-4-lecturas-requeridas-videos-del-curso-y-materiales-adicionales "1.4 Lecturas requeridas, videos del curso y materiales adicionales").
> 1. Caracterice la arquitectura cliente-servidor y presente un diagrama para una mejor ilustración.
> 2. Enumere las ventajas y desventajas de la arquitectura cliente-servidor.
> 3. ¿Cuáles son los servicios más comunes ofrecidos por un servidor?
> 4. ¿Qué motivó el surgimiento de los sistemas operativo para servidores?
> 5. Nombre las principales características de los sistemas operativos de servidores.
> 
> Suba un **archivo PDF** con las respuestas a los puntos listados arriba.

1. Tiene la posibilidad de crear aplicaciones que accedan a las bases de datos de HFSQL Client/Server.
Una aplicación HFSQL Client/Server ejecuta una aplicación en varios ordenadores (llamados ordenadores cliente) y almacena las bases de datos y los procesos en un servidor. Este modo de funcionamiento hace que los tiempos de respuesta sean más rápidos y fiables, y simplifica el mantenimiento de la base de datos..
2. VENTAJAS DEL MODELO
**Centralización de los recursos:** el servidor debe gestionar los recursos comunes a todos los
usuarios;
**Mejor seguridad:** la concentración de datos en un único punto facilita la gestión y compartición adecuada;
**Administración:** a través del servidor es posible administrar toda la red;
**Escalabilidad e paralelismo:** es posible agregar o quitar clientes de una manera sencilla y interrumpir el funcionamiento de la red;

DESVENTAJAS DEL MODELO

**Costo:** los costos pueden ser elevados, dependiendo del servicio;
**Confiabilidad:** el servidor es el único responsable por mantener funcionamiento. En caso de que ocurran problemas en el servidor, los servicios dejaran de ser proporcionados;
**Mantenimiento:** las diversas partes involucradas no siempre funcionan bien juntas;
**Gestión:** la gestión del ambiente es compleja.

3. Los servicios más comunes ofrecidos por un servidor:

- Servicios de archivos: Almacenamiento, acceso y compartición de archivos.
- Servicios de impresión: Impresión de documentos y otros archivos.
- Servicios de bases de datos: Almacenamiento, acceso y gestión de datos.
- Servicios de correo electrónico: Envío y recepción de correos electrónicos.
- Servicios web: Proporcionar contenido y servicios a través de la web.
- Servicios de aplicaciones: Ejecutar aplicaciones para los clientes.

4. El surgimiento de los sistemas operativos para servidores fue motivado por la necesidad de contar con sistemas operativos optimizados para las demandas específicas de los servidores, Como una alta disponibilidad, seguros, escalables, de alto rendimiento y que pueda ser administrada remotamente.

5. Características principales de los sistemas operativos para servidores:

- **Estabilidad:** Deben ser estables y confiables para minimizar los fallos y tiempos de inactividad.
- **Seguridad:** Deben incluir robustas medidas de seguridad para proteger los datos y recursos.
- **Escalabilidad:** Deben ser escalables para adaptarse a diferentes cargas de trabajo y tamaños de red.
- **Rendimiento:** Deben tener un alto rendimiento para procesar las solicitudes de manera eficiente.
- **Gestión remota:** Deben permitir la administración remota para facilitar su mantenimiento.
- **Alta disponibilidad:** Deben ofrecer mecanismos para garantizar la disponibilidad continua del servicio.
- **Soporte para múltiples usuarios:** Deben ser capaces de manejar un gran número de usuarios simultáneos.
- **Flexibilidad:** Deben ser flexibles para adaptarse a diferentes necesidades y configuraciones.

#### LABORATORIO

> [!help] Consignas
> **Descripción de la actividad:**  
> 1. Instale VirtualBox en su computadora personal ([Downloads – Oracle VM VirtualBoxLinks to an external site.](https://www.virtualbox.org/wiki/Downloads)).
> 2. Investigue los requisitos mínimos (en términos de memoria, procesador, disco duro y otros) para la instalación de la última versión de Ubuntu Server. 
> 3. Investigue los requisitos mínimos (en cuanto a memoria, procesador, disco duro y otros) para la instalación de Windows Server. 
> 4. Cree dos Máquinas Virtuales (VM) en VirtualBox con los requisitos necesarios tanto para la Ubuntu Server 22.04 como para Windows Server 2022 (desktop experience) (Agregue 1 GB más de RAM y 40 Gigabytes más de capacidad de disco que los requeridos para cada uno). 
> 5. Instale el sistema operativo Ubuntu Server en una VM (asigne un nombre a la PC con el siguiente formato: Por ejemplo, inicial del nombre y apellido:  jperez_l). 
> 	1. Seleccione “OpenSSH Server” durante la instalación.
> 	2.Link ISO: [Ubuntu Server ISOLinks to an external site.](https://ubuntu.com/download/server)   
> 6. Instale el sistema operativo Windows Server en la otra VM (asigne un nombre a la PC con el siguiente formato: Por ejemplo, inicial del nombre y apellido:  jperez_w).
> 	1. Link ISO: [Windows Server ISOLinks to an external site.](https://www.microsoft.com/en-us/evalcenter/download-windows-server-2022) 
> 	2. Posterior a la instalación, habilite OpenSSH         
>7. Inicie sesión en cada máquina virtual y verifique desde el sistema operativo si el hardware y el software en la VM son los esperados (Ver tamaño del disco duro, tamaño de la memoria, características del procesador y versión del sistema operativo). 
>	1. free -mh 
>	2. uname -a 
>	3. etc.
>8. Tome un Snapshot de cada máquina virtual en VirtualBox en apagado. 
>9. Responde a la siguiente pregunta: ¿Qué diferencias encuentras entre un Sistema Operativo de Escritorio y Servidor? 
>10. Conclusiones: Escriba lo que aprendió de este laboratorio. Documente los resultados de su investigación con unas pocas líneas de texto y capturas de pantalla para cada punto anterior en un **archivo PDF**.

1. 
![[Pasted image 20240702123204.png]]
2. Ubuntu server System requeriments
	1. Arquitectura
		- amd64 (64-bit Intel/AMD)
		- arm64 (64-bit Arm)
		- armhf (32-bit Arm)
		- ppc64el (64-bit Power)
		- riscv64 (64-bit RISC-V)
		- s390x (64-bit Mainframe)
	2. Memoria RAM minima: 1024 MB, Recomendada 3 GB o mas
	3. Espacio en disco minimo: 5 GB (ISO installs) 4 GB (cloud images) Minimo recomendado 25 GB o mas.
3. Windows server system requeriments
	1. Arquitectura
		- Procesador de 64 bits a 1,4 GHz
		- Compatible con el conjunto de instrucciones x64
		- Admite DEP y NX
		- Admite CMPXCHG16b, LAHF/SAHF y PrefetchW
		- Admite la traducción de direcciones de segundo nivel (EPT o NPT)
	2. Memoria RAM 512 MB para Server Core 2 GB para servidor con experiencia de escritorio
	3. Espacio en disco minimo: 32 GB.
4. 
5. Los sistemas operativos de escritorio y servidor, si bien comparten algunos componentes básicos, están diseñados con propósitos y usuarios finales distintos, lo que se refleja en sus características y funcionalidades. A continuación, se detalla un análisis comparativo de sus principales diferencias:
	Propósito:
	- **Escritorio:** Diseñados para el uso personal, la productividad y el entretenimiento de usuarios individuales. Priorizan la facilidad de uso, la interfaz gráfica intuitiva y la compatibilidad con una amplia gama de software y aplicaciones.
	- **Servidor:** Diseñados para gestionar y proporcionar servicios a otros sistemas o usuarios en una red. Priorizan la estabilidad, la seguridad, el rendimiento y la capacidad de manejar grandes cargas de trabajo.

	**Usuarios:**

- **Escritorio:** Usuarios individuales, como estudiantes, profesionales, entusiastas de la informática o usuarios domésticos.
- **Servidor:** Administradores de sistemas, personal de TI, desarrolladores y aplicaciones que requieren acceso a recursos compartidos o servicios de red.

---
## Semana 2 

### Fundamentos de redes e ‘Internetworking’

#### FORO

 > [!QUESTION]
> Investigue y analice NAT y subneting como estrategias para reducir la escasez de IPV4. Cuál diría usted que tuvo mejores resultados en ese propósito y por qué?

NAT y subneting como estrategias para reducir la escasez de IPv4:

¿Cuál ha tenido mejores resultados?

Ambas han sido fundamentales para reducir la escasez de IPv4. Cada una tiene sus propias ventajas y desventajas mientras que NAT tiene una implementación sencilla que permite la conectividad a internet sin necesidad de una dirección IPv4 pública para cada dispositivo.
Puede dificultar la resolución de problemas de red, también limita la comunicación directa entre dispositivos en diferentes redes NAT, esto no soluciona el problema a largo plazo de la escasez de direcciones IPv4. En cuanto al Subneting tiene un uso mas eficiente del espacio de direcciones IPv4 a su vez reduce el tráfico de broadcast y mejora la seguridad de la red. Así como nos permite un mejor control del acceso a la red. A diferencia de NAT posee una implementación mas compleja, requiere un mayor conocimiento de redes TCP/IP y puede ser necesario reconfigurar los dispositivos de red al cambiar la configuración de subred.

Mi conclusión es que NAT fue la mas utilizada para reducir la escasez de IPv4 su facilidad de implementación. Sin embargo, el subneting es una estrategia más eficiente a largo plazo para el uso del espacio de direcciones IPv4.

#### TAREA

La comunicación cliente-servidor permite la interacción entre procesos en diferentes máquinas. Entre los métodos más comunes para implementar esta comunicación se encuentran los sockets, las llamadas a procedimientos remotos (RPC) y las interfaces de programación de aplicaciones (API).

1. Sockets: Los sockets son puntos finales de comunicación que permiten la transferencia de datos entre procesos en una red. Se basan en protocolos de transporte como TCP o UDP para establecer conexiones confiables o no confiables, respectivamente. Capa OSI:  Transporte (Capa 4).



```
Cliente                        Servidor
 |                            |
 |  Aplicación --------------> Sockets <-----> Aplicación |
 |                            |
```

2. RPC (Remote Procedure Calls): El RPC abstrae la comunicación remota como si se invocara un procedimiento local. El cliente invoca un procedimiento en el servidor, el cual lo ejecuta y devuelve el resultado. Capa OSI Aplicación (Capa 7) y Transporte (Capa 4).

```
Cliente                        Servidor
 |                            |
 |  Aplicación --------------> RPC <-----> Aplicación |
 |                            |
 |                            |
 |                        Protocolo de transporte (TCP/UDP) |
```

3. API (Application Program Interface): Las API son conjuntos de definiciones y protocolos que especifican cómo interactúan las aplicaciones con un servicio o sistema. Proporcionan una capa de abstracción que simplifica el acceso a funcionalidades complejas. La capa OSI varía según la API específica. Las API pueden abarcar desde la capa de aplicación (Capa 7) hasta capas inferiores como la de transporte (Capa 4) o la de red (Capa 3).

```
Cliente                        Servidor
 |                            |
 |  Aplicación --------------> API <-----> Implementación del servicio |
 |                            |
 |                            |
 |                        (Capas variables según la API) |
```

#### LABORATORIO
> [!help]
> 1. Usando la consola de VirtualBox, iniciar sesión en las VMs creadas en el Lab de la semana 1 (Windows y Ubuntu server).
>2. Usando los comandos _ip_ (Ubuntu), _ipconfig_ (Windows), identifique las siguientes:       
>- IP privada y a que clase pertenece? 
>- IP pública y a que clase pertenece?    
>Usar el siguiente comando: curl ifconfig.me    
>  - Obtener la configuración de DHCP habilitado.
>  - Obtener el número de Interfaces Disponibles. 
> 3. Adicionar una segunda interfaz de red de tipo Bridged Adapter en ambas VMs 
>    - Iniciar la VM de Ubuntu y edite el archivo **_/etc/netplan/00-installer-config.yaml._** Agregue dos lineas para la nueva interfaz de red, como sigue:        
  > 	     enp0S8:  
 > 	        dhcp4: true        
 >       Para aplicar cambios, ejecute: _**sudo netplan apply** 
>4. Repetir el paso 2 y registrar los cambios en el resultado.
>5. Iniciar una conexión SSH a cada VM usando la interfaz 1 (NAT), use VirtualBox para realizar port-forwarding.  
>    - Recursos de soporte:   
>    - Link: [¿Qué es Port Forwarding?](https://culturacion.com/que-es-port-forwarding/)
>    - Link: [Túnel SSH port forwarding: Local, remote y dynamic](https://www.zonasystem.com/2019/01/tunel-ssh-port-forwarding-local-remote-dynamic.html)
>6. Iniciar una conexión SSH a cada VM usando la interfaz 2 (Bridged) 
>7. Verificar comunicación entre VMs usando el comando “ping”.
>  - VM 1 a VM2 
 >  - VM 2 a VM1 
>    - Investigue qué protocolo usa el comando _ping_.
 >   - Explique el alcance del tipo de interfaz “NAT” 
>    - Explique el alcance del tipo de interfaz “Bridged” 
>8. Verificar comunicación a una dirección externa usando el comando “ping”, por ejemplo. [www.google.com](http://www.google.com/)
>9. Use netcat (Linux) y telnet (Windows) y verifique que el puerto correspondiente al servicio SSH esté escuchando 
>10. Use el comando traceroute(Linux) , por ejemplo “traceroute [www.amazon.com.au](http://www.amazon.com.au/)
  >  - Investigue que protocolo usa
 >   - Secuencia de saltos 
>    - Número de saltos 
>11. Use el comando tracert (Windows) , por ejemplo “tracert [www.amazon.com.au](http://www.amazon.com.au/) 
 >   - Investigue que protocolo usa 
 >   - Secuencia de saltos 
  >  - Número de saltos
>12. Comparar los resultados del paso 10 y 11. Marcar las diferencias.
>13. Cambiar la IP/DNS de la segunda interfaz (Bridged) para usar una IPV4 estática en la VM de Windows    
>    - DNS: 8.8.8.8

2. Usando los comandos _ip_ (Ubuntu), _ipconfig_ 
	1. Windows
		- IP privada o "IPv4 Address:". El valor después de los dos puntos (:) es la dirección IP privada ![[Pasted image 20240710122507.png]]  Y es de clase "A" 
		- IP pública con el comando curl ifconfig.me podemos ver la ip publica ![[Pasted image 20240710123819.png]] Y es de clase "C"
		- Usar el siguiente comando: curl ifconfig.me    
			- Para poder usar el DHCP primero tuve que agregar la caracteristica al sistema lo cual fue seguir estos pasos 
				- - **Instalación:**
				    - Abra el **Administrador de servidores**.
				    - Vaya a **Administrar** > **Agregar roles y características**.
				    - Seleccione **Servidor DHCP** y haga clic en **Siguiente**.
				    - Revise las características necesarias y haga clic en **Siguiente**.
				    - Haga clic en **Instalar**.
				    - Una vez finalizada la instalación, abra el **Consola DHCP**.
				- **Configuración:**
				    - Haga clic con el botón derecho en **Servidor DHCP** y seleccione **Nuevo ámbito**.
				    - Siga el asistente para crear un nuevo ámbito, especificando el rango de direcciones IP, la máscara de subred, el servidor DNS y otras opciones.
				    - Agregue exclusiones de direcciones IP si es necesario.
				    - Active el ámbito.
			 - Para habilitar el DHCP se uso. Se uso el comando ipconfig /all  para ver todas las interfaces disponibles![[Pasted image 20240710141945.png]]
	2. Linux
		- Se usa el comando `ip addr show` . Si queremos ver por ethernet buscamos eth0 si queremos encontrar por Wi-Fi wlan0![[Pasted image 20240710133220.png]] es de clase "A"
		- Para encontrar la ip publica usamos el comando `curl ifconfig.me` ![[Pasted image 20240710133612.png]]
		- ![[Pasted image 20240710163918.png]]
3. ![[Pasted image 20240710165049.png]] ![[Pasted image 20240710171038.png]]
	![[Pasted image 20240711124411.png]]
4.  Se ve una nueva interfaz: ![[Pasted image 20240710185249.png]]
5. pero no se permite usar a la interfaz 1(NAT) ![[Pasted image 20240711133117.png]]![[Pasted image 20240711133343.png]] Añadi una regla en la Vm que nos permita abrir un puerto donde nos permite conectar por ssh al NAT, para ello use el comando `ssh <usuario>@<ip> -p <puerto-host>`
![[Pasted image 20240711134820.png]]
6. Se puede hacer un ssh a la interfaz 3 (bridged) ![[Pasted image 20240711132826.png]]
7. ![[Pasted image 20240711131619.png]] Aca vemos como hacer ping desde windows a el linux-server
8.  Podemos hacer ping a una dirección externa sin problemas![[Pasted image 20240711140030.png]]
9. El comando básico para verificar el estado del puerto SSH con `netcat` es el siguiente:
`nc -v -w 1 <direccionIP> <puerto-ip>` ![[Pasted image 20240711151411.png]]
En Windows el comando `telnet` no está disponible de forma predeterminada en Windows Server. A partir de Windows Server 2008, Microsoft decidió eliminar esta herramienta debido a sus problemas de seguridad inherentes. podemos descargar NetCat.
10. El protocolo utilizado es Internet Control Message Protocol. Esto se debe a que el comando `tracert` / `traceroute` ambos utilizan paquetes ICMP para rastrear la ruta. Tienen una Secuencia de saltos que muestra la ruta que toman los paquetes para llegar al destino. El número de saltos es la cantidad de enrutadores que atraviesan los paquetes para llegar al destino.![[Pasted image 20240711155338.png]]
11. ![[Pasted image 20240711161305.png]]
12. - La secuencia de saltos (enrutadores) puede variar ligeramente entre las ejecuciones y entre Linux y Windows debido al enrutamiento dinámico y la selección de rutas aleatorias. Mientras que la cantidad total de saltos y los nombres de host o direcciones IP de los enrutadores principales deberían ser similares.
13. Abrimos Centro de redes y recursos compartidos
    - Seleccione "Redes e Internet".
    - Haga clic en "Centro de redes y recursos compartidos".   
    - En el panel izquierdo, seleccione "Cambiar la configuración del adaptador".
	- Seleccionar la interfaz Bridged.
    - Haga clic derecho en la interfaz de red Bridged y seleccione "Propiedades".
- Abrir las propiedades del protocolo TCP/IPv4:
    - En la ventana de propiedades de la interfaz de red, seleccione "Protocolo de Internet versión 4 (TCP/IPv4)" y haga clic en el botón "Propiedades".
- Configurar la IP estática:
    
    - Seleccione la opción "Usar la siguiente dirección IP:".
    - Ingrese la dirección IP estática que desea usar para la VM en el campo "Dirección IP".
    - Ingrese la máscara de subred correspondiente a su red en el campo "Máscara de subred".
    - Escriba la dirección IP de su puerta de enlace predeterminada en el campo "Puerta de enlace predeterminada".
- **Configurar el DNS estático:**
    
    - Seleccione la opción "Usar los siguientes servidores DNS:".
    - Ingrese el DNS primario 8.8.8.8 en el campo "Servidor DNS preferido".
    - (Opcional) Ingrese un DNS secundario en el campo "Servidor DNS alternativo".
- **Guardar los cambios:**
    
    - Haga clic en el botón "Aceptar" para guardar la configuración de IP y DNS estáticas.
    - Cierre las ventanas abiertas restantes.![[Pasted image 20240711162818.png]]

---
## Semana 3 

### Titulo
[[Concepto de sistemas distribuidos]]
[[Seguridad en Sistemas distribuidos]]
[[Active Directory]]

#### FORO
 > [!QUESTION]
> ¿Cuáles son los 4 algoritmos de encriptación más usados hoy en día, y qué característica principal tienen en común?
> 
¿Usted cree que la computación cuántica podría poner en peligro la eficacia de los algoritmos de encriptación actuales? ¿Por qué?

Los algoritmos de cifrado que están actualmente en uso son: 

AES Advanced Encryption Standard es un algoritmo de cifrado simétrico que opera en bloques esto significa que utiliza la misma clave tanto para encriptar como para desencriptar datos. El remitente y el receptor deben conocer y utilizar la misma clave secreta de cifrado. Se utiliza para cifrar información personal, empresarial y del gobierno La característica clave es alto nivel de seguridad, con diferentes opciones de cifrado disponibles en 128192256 bits para adaptarse a diferentes necesidades.

El cifrado es la clave para asegurar Internet y es tan importante El sistema está construido sobre dos claves, una clave pública y una clave privada para el cifrado y descifrado La función principal de Key es facilitar la comunicación segura a través del intercambio de claves públicas, eliminando la necesidad de compartir claves secretas. 

La seguridad digital ahora se centra en otro algoritmo de cifrado asimétrico clave, dh diffie-hellman Asegura la transmisión de claves confidenciales a través de un medio inseguro 
La función principal de Key es permitir la creación de claves compartidas confidenciales sin el requisito de una clave pre-compartida. 

ECC Elliptic-curve cryptography tiene buena eficiencia computacional y capacidad para proporcionar seguridad equivalente con claves más cortas. Su característica principal es su alta seguridad y eficiencia, por lo que es un buen ajuste para aplicaciones que requieren bajos recursos computacionales.

La computación cuántica puede interrumpir los métodos de encriptación. Los algoritmos Rsa y dh se basan en problemas matemáticos que los ordenadores cuánticos podrían resolver con facilidad y que comprometerían la seguridad de encriptación. 
#### TAREA
1. Investigue e ilustre de forma gráfica (respetando derechos de autor) cómo el uso de las llaves públicas y privadas permiten la creación de firmas digitales. 

2. Investigue e ilustre qué es una VPN y por qué fueron creadas las VPNs, es decir, qué problema tratan de resolver?
Las firmas digitales son herramientas criptograficas que nos permiten verificar las firmas digitales y garantizar su autenticidad y seguridad. Las huellas digitales virtuales que conectan inequívocamente un documento con su autor para captar su funcionamiento.

La llave pública es como la llave que todos pueden ver y compartir. Permite a cualquiera "leer" el mensaje o documento, pero no modificarlo. Es como una caja de correo, accesible a todos, pero solo el destinatario tiene la llave para abrirla. Por otro lado, la llave privada es como la llave secreta que solo el propietario conoce. Es única e intransferible, y permite al autor "firmar" el mensaje o documento, creando un sello digital que garantiza su origen y contenido inalterado. Es como la llave maestra de la caja fuerte, solo el dueño la tiene y con ella puede asegurar el contenido.

Para poder tener una firma digital primero necesitamos crear un par de llaves una publica y otra privada, el autor crea el archivo que quiere firmar, utilizando un software de firma digital, el autor une el archivo con su llave privada, esto genera un bloque de datos único e inseparable. Para verificar el funcionamiento de la firma digital el receptor recibe el archivo  y obtiene la clave publica del autor, ya sea por un canal seguro o en el mismo archivo, en el software de firma digital combina el archivo con la clave publica del autor, donde se verifica que la llave/clave sea la correcta.

VPN o Virtual Private Network es una herramienta para proteger la privacidad y confidencialidad en internet, este encripta tu tráfico de internet y dirigiéndolo a través de un servidor intermediario. De esta manera, la información viaja oculta y protegida. Una VPN nos permiten acceder de forma segura a redes corporativas o recursos locales desde cualquier lugar del mundo. Ocultan tu dirección IP real y encriptan tu tráfico de internet, evitando que terceros rastreen tu actividad en línea. Permiten acceder a contenido web bloqueado en tu región, como plataformas de streaming o sitios web con restricciones geopolíticas.

#### LABORATORIO


---
## Semana 4

### Autenticación y Autorización

#### FORO
 > [!QUESTION]
> ¿Qué es y qué impacto ha tenido la tecnología "Single sign-on" (inicio de sesión única ) en nuestros días? ¿Cuál es el principal problema que resuelve ésta tecnología? y ¿Sobre qué protocolos se establece?

El **inicio de sesión único** o **Single sign-on** (SSO) Nos permite acceder a todo lo que necesitamos con una única autenticación. Esta simplicidad no solo es conveniente, sino que también aporta importantes beneficios en materia de seguridad y productividad. 

Puede haber hasta tres sesiones diferentes para un usuario con SSO:

- Sesión local mantenida por la aplicación.

- Sesión del servidor de autorización, si SSO está habilitado

- Sesión de proveedor de identidad ([[IdP]]), si el usuario eligió iniciar sesión a través de un proveedor de identidad (como Google, Facebook o un proveedor de identidad SAML empresarial)

Con SSO, un dominio central realiza la [[autenticación]] y luego comparte la sesión con otros dominios. La forma en que se comparte una sesión puede diferir entre los protocolos SSO, pero el concepto general es el mismo.

El problema que resuelve el SSO es la gestión de múltiples identidades y contraseñas Ya que los usuarios necesitan acceder a una gran cantidad de aplicaciones y servicios, cada uno de los cuales requiere un nombre de usuario y contraseña únicos. La idea de SSO es introducir las credenciales una sola vez. A partir de ese momento, podes acceder a todas las aplicaciones habilitadas para SSO sin necesidad de volver a introducir el usuario y la  contraseña. Esta autenticación única se basa en la confianza entre el usuario, el proveedor de servicios (SP) y un [[IdP]].

Los protocolos SSO mas comunes son:

- SAML (Security Assertion Markup Language): Es uno de los más utilizados, especialmente en entornos empresariales. SAML se basa en la comunicación XML entre el IdP, el SP y el usuario.
    
- OpenID Connect: Un protocolo basado en OAuth 2.0 que simplifica la implementación del SSO y ofrece mayor flexibilidad. OpenID Connect se utiliza ampliamente en aplicaciones web y móviles.
    
- WS-Federation: Un protocolo más antiguo que todavía se utiliza en algunos entornos. WS-Federation es similar a SAML, pero utiliza formatos de mensaje y mecanismos de transporte diferentes.
    
- Kerberos: Un protocolo de autenticación que se utiliza principalmente en redes Windows. Kerberos no es un protocolo SSO puro, pero se puede integrar con otros protocolos para proporcionar SSO en entornos Windows.

#### TAREA

Los pasos necesarios para unir una computadora con sistema operativo Ubuntu Desktop a un dominio de Windows Server utilizando SSSD (Security Assertion Markup Language Security Assertion Markup Language). SSSD es una herramienta que permite a los sistemas Linux autenticarse con dominios Active Directory de Windows Server.

**Prerrequisitos:**

- Computadora con Ubuntu Desktop
- Servidor Windows Server con Active Directory configurado
- Conectividad de red entre la computadora Ubuntu y el servidor Windows Server
- Cuenta de usuario con permisos administrativos en ambos sistemas

1.  Debemos actualizar e instalar paquetes necesarios:

>``` bash
>sudo apt update
>```

2. Instalar los paquetes necesarios para SSSD, Kerberos y herramientas de administración de dominio:

```bash
sudo apt install -y realmd libnss-sss libpam-sss sssd sssd-tools adcli samba-common-bin oddjob oddjob-mkhomedir packagekit
```

3.  Luego procedemos a editar el archivo de configuración de SSSD:

```bash
sudo nano /etc/sssd/sssd.conf
```

- Agregamos y modificamos las siguientes líneas según su entorno:

```
[sssd]
domain = [NOMBRE_DE_DOMINIO_WINDOWS_SERVER]
realmd_opts = 2
dc = [NOMBRE_DEL_DOMINIO_WINDOWS_SERVER]
ad_server = [DIRECCION_IP_DEL_SERVIDOR_WINDOWS_SERVER]
cache_ttl = 600
krb5_realm = [NOMBRE_DE_DOMINIO_WINDOWS_SERVER]
krb5_server = [DIRECCION_IP_DEL_SERVIDOR_WINDOWS_SERVER]
```

- Reemplazamos `[NOMBRE_DE_DOMINIO_WINDOWS_SERVER]`, `[NOMBRE_DEL_DOMINIO_WINDOWS_SERVER]`, y `[DIRECCION_IP_DEL_SERVIDOR_WINDOWS_SERVER]` con los valores correspondientes al entorno.

4.  Luego comenzamos a configurar Kerberos

- Editamos el archivo de configuración de Kerberos con el comando:

```bash
sudo nano /etc/krb5.conf
```

- Agregamos y modificamos las siguientes líneas según su entorno:

```
[libdefaults]
default_realm = [NOMBRE_DE_DOMINIO_WINDOWS_SERVER]
ticket_lifetime = 24h
renew_lifetime = 7d
forwardable = true
rdns = [DIRECCION_IP_DEL_SERVIDOR_WINDOWS_SERVER] [DIRECCION_IP_DEL_SERVIDOR_WINDOWS_SERVER_SECUNDARIO]
```

- Reemplazamos `[NOMBRE_DE_DOMINIO_WINDOWS_SERVER]`, `[DIRECCION_IP_DEL_SERVIDOR_WINDOWS_SERVER]`, y `[DIRECCION_IP_DEL_SERVIDOR_WINDOWS_SERVER_SECUNDARIO]` con los valores correspondientes a su entorno.

5. Unirse la computadora al dominio de Windows Server utilizando el siguiente comando:

```bash
sudo realm join [NOMBRE_DE_DOMINIO_WINDOWS_SERVER]
```

- Ingresamos las credenciales de una cuenta de usuario con permisos administrativos en el dominio de Windows Server cuando se le solicite.

6. Para finalizar verificamos que la unión al dominio se haya realizado correctamente ejecutando el comando.

```bash
sestatus
```

- La salida debería mostrar `Domain: [NOMBRE_DE_DOMINIO_WINDOWS_SERVER]` si la unión se realizó correctamente.

7. Ajustar el comportamiento de PAM editando el archivo de configuración de PAM para SSSD.
```bash
sudo nano /etc/pam.d/sssd
```

- Agregamos las siguientes líneas al final del archivo:

```
auth    sufficient    pam_sss.so
account  sufficient    pam_sss.so
password sufficient    pam_sss.so
```

8. Convertir al administrador del dominio en administrador local editando el archivo sudoers para permitir al administrador del dominio tener privilegios administrativos en la computadora

``` bash
sudo nano /etc/sudoers
```

- Agregamos la siguiente línea al final del archivo:

```
%domain_admins ALL=(ALL) ALL
```

- Reemplazamos  `%domain_admins` con el grupo de administradores del dominio de Windows Server.

9. Reiniciamos el equipo para que los cambios surtan efecto.
#### LABORATORIO
![[Laboratorio S-4 SO Agustin De Luca  (1).pdf]]

---
## Semana 5

### Configuración de SOS

#### FORO
 > [!QUESTION]
> Existe el pensamiento extendido que los sistemas operativos Windows son menos seguros que los sistemas operativos Linux. ¿Usted cree que se podría decir que eso es verdad en relación a los sistemas operativos tipo servidor actuales? Argumente su respuesta.
**Absolutamente, es un tema que ha sido ampliamente discutido y analizado por expertos en seguridad informática.**

En mi opinión Linux suele considerarse más seguro debido a su codigo abierto y a una comunidad global de desarrolladores, se examina y mejora constantemente el código, y gracias a la comunidad se identifica y corrige vulnerabilidades de manera más rápida. Al ser menos popular que Windows en el escritorio, Linux atrae menos atención por parte de los creadores de malware. Para finalizar Linux está diseñado para otorgar a los usuarios y procesos solo los permisos necesarios para realizar sus tareas, lo que limita el impacto potencial de una vulnerabilidad. Aunque actualmente Windows hizo grandes avances en seguridad en los últimos años hay factores como su mayor cuota de mercado y la complejidad de su ecosistema lo hacen un objetivo más atractivo para los atacantes.


#### TAREA

El 5 de Junio de 2014, se descubrió una grave vulnerabilidad en la implementación de OpenSSL, una biblioteca de criptografía ampliamente utilizada en servidores web y otros servicios de red. La vulnerabilidad, conocida como Heartbleed, permitía a un atacante robar hasta 64 KB de memoria del servidor, lo que incluía claves privadas, contraseñas y otros datos. Los atacantes podían enviar solicitudes especialmente diseñadas para provocar que este devolviera parte de su memoria. Esto se podía haber prevenido con la actualización de OpenSSL a una versión corregida lo antes posible así como un monitoreo cuidadoso o constante de los logs del servidor para detectar actividad sospechosa. Este problema fue descubierto por Masashi Kikuchi (Lepidum Co. Ltd.)

En Windows durante el año 2017, el ransomware WannaCry se propagaba automáticamente a través de redes, infectando sistemas vulnerables y encriptando sus archivos. Este se propagó rápidamente por todo el mundo, infectando cientos de miles de computadoras, muchas de ellas ejecutando sistemas operativos Windows Server desactualizados. WannaCry aprovechó una vulnerabilidad en el servicio de archivos compartidos de SMB (Server Message Block) de Microsoft, una falla de ejecución de código remoto que permitía a un atacante ejecutar código arbitrario en un sistema vulnerable. Los atacantes exigían un pago en bitcoins para restaurar el acceso a los datos. Microsoft había lanzado un parche de seguridad para corregir la vulnerabilidad semanas antes del ataque. Las organizaciones afectadas no habían aplicado el parche a tiempo, por este caso una de las acciones de prevención seria actualizar constantemente los sistemas y servidores, además de tener un buen manejo de los permisos de acceso, uso y escritura que tienen los usuarios.

 
#### LABORATORIO


---
## Semana 6

### Titulo


#### FORO
 > [!QUESTION]
>Pensando en el panorama actual de la tecnología, los sistemas distribuidos se han convertido en una parte esencial de nuestra vida. Analice algunos servicios que utiliza actualmente y que se hayan difundido a nivel mundial. Explique cuáles son los motivos de su éxito y aceptación. Además, mencione cuáles cree que son los desafíos más importantes que enfrentan las empresas cuando desean proveer nuevas soluciones o servicios a escala mundial hoy en día.

Algunos servicios distribuidos de uso común son las
 Redes sociales: Plataformas que conectan a miles de millones de usuarios en todo el mundo. Su éxito se debe a una interfaz intuitiva que facilita la interacción, el consumo de contenido y que adapta el contenido a los intereses de cada usuario. 
 Servicios de streaming: nos permiten acceder a una vasta biblioteca de contenido multimedia en cualquier momento y lugar. Tienen un catálogo amplio y variad que satisface los gustos de una amplia audiencia. Compartiendo con las redes sociales una UI que facilita la búsqueda y reproducción de contenido.
 Servicios en la nube: Ofrecen una amplia gama de servicios en la nube, como almacenamiento, computación y bases de datos. Tienen ventajas como que permite ajustar los recursos según las necesidades. Reduce los costos iniciales y permite escalar de forma flexible. También ofrece soluciones para diversas necesidades empresariales.

Los motivos de su éxito se deben a: Los servicios distribuidos están disponibles desde cualquier dispositivo con conexión a internet. Se adaptan a las preferencias y necesidades individuales de cada usuario. Pueden manejar un gran volumen de usuarios y datos.
También Ofrecen alta disponibilidad y alta tolerancia a fallos.

Desafíos para las empresas: El diseño y desarrollo de sistemas distribuidos a gran escala es complejo y requiere de conocimientos especializados para que funcione de manera adecuada, segura, escalable y debe reducir la latencia para ofrecer una buena UX asi como garantizar la consistencia de los datos en múltiples ubicaciones es un desafío importante. Si bien puede ser trabajado constantemente siempre es importante identificar y solucionar errores en sistemas distribuidos. Las empresas deben cumplir con una variedad de regulaciones, como GDPR y CCPA, lo que implica desafíos adicionales en términos de seguridad y privacidad de los datos.

#### TAREA

El **Sistema de Nombres de Dominio (DNS)** es como una guía telefónica de internet. Convierte los nombres de dominio que son fáciles de recordar (como google.com) en direcciones IP numéricas que las computadoras utilizan para comunicarse entre sí.

**Google Public DNS** es un servicio gratuito ofrecido por Google que se destaca por que sus servidores DNS están optimizados para ofrecer una resolución rápida de nombres de dominio, lo que puede mejorar la velocidad de carga de las páginas web. La red global de servidores de Google garantiza una alta disponibilidad y tolerancia a fallos así como implementación de  medidas de seguridad para proteger contra amenazas como el phishing y el malware. Google DNS no almacena los registros de DNS de forma permanente, lo que ayuda a proteger tu privacidad.

Algunos usos del DNS de Google
- **Enrutadores:** Muchos enrutadores domésticos y empresariales permiten configurar el DNS de forma personalizada.
- **Dispositivos IoT:** Algunos dispositivos IoT pueden configurarse para utilizar el DNS de Google.
- **Servidores web:** Si tienes un servidor web, puedes configurar el DNS para que apunte a tu servidor.
Para configurar una máquina virtual para usar Google DNS en 

Windows:

- **Panel de control:** Accede al Panel de control, selecciona "Redes e Internet" y luego "Centro de redes y recursos compartidos".
- **Cambiar configuración del adaptador:** Haz clic derecho en tu conexión de red y selecciona "Propiedades".
- **Protocolo de Internet versión 4 (TCP/IPv4):** Haz doble clic y en la pestaña "General" busca los campos "Servidor DNS preferido" y "Servidor DNS alternativo".
- **Ingresar direcciones:** Introduce las direcciones IP de Google DNS (8.8.8.8 y 8.8.4.4) en los campos correspondientes.

Linux:

- **Editor de texto:** Utiliza un editor de texto con privilegios de root (por ejemplo, `sudo nano /etc/resolv.conf`) para editar el archivo de configuración de resolv.
- **Agregar nombres de servidor:** Añade las siguientes líneas al final del archivo, reemplazando `nameserver` por tus direcciones IP preferidas:

```
nameserver 8.8.8.8
nameserver 8.8.4.4
```

- **Guardar cambios:** Guarda el archivo y verifica que los cambios se hayan aplicado.

#### LABORATORIO


---
## Semana 7

### Titulo

#### FORO

> [!QUESTION]
> limitando las opciones de instalación a las explicadas en este tema, explique en qué casos seria ventajoso optar por una máquina virtual o usar contenedores, desarrolle su respuesta.

Es preferente usar VM si la aplicación requiere muchos recursos o tiene dependencias específicas de hardware, una VM puede ser la mejor opción o si se necesita ejecutar diferentes sistemas operativos en la misma infraestructura, las VMs te ofrecen esa flexibilidad. Si la seguridad es una prioridad máxima y necesitas aislar completamente cada aplicación o si estás migrando aplicaciones heredadas, las VMs facilitan el proceso al permitir ejecutarlas en un entorno virtualizado.

Mientras  que los contenedores comparten el kernel del sistema operativo host, lo que reduce el overhead y aumenta la eficiencia. Estos son altamente portátiles y pueden ejecutarse en cualquier plataforma que soporte el motor de contenedores (como Docker).
Esto nos permite escalar las aplicaciones de forma rápida y sencilla. también tiene una mayor densidad de aplicaciones por servidor, lo que optimiza el uso de los recursos.
Estos son ideales para arquitecturas de microservicios, donde cada servicio se ejecuta en su propio contenedor. Facilitan los procesos de desarrollo, testing y despliegue, gracias a su portabilidad y facilidad de gestión. Son mejores para el desarrollo de aplicaciones diseñadas para la nube, son eficientes para maximizar el uso de los recursos del servidor


#### TAREA

#### LABORATORIO


---
## Proyecto Final

Los contenedores y máquinas virtuales (VM) son dos tecnologías clave en este ámbito, cada una con sus propias fortalezas y debilidades. Comprender sus diferencias es fundamental para elegir la herramienta adecuada para cada escenario.

### Aislamiento: Capas de Abstracción

Los contenedores comparten el kernel del sistema operativo host, pero aíslan los procesos, redes, archivos y otros recursos de cada aplicación en espacios de nombres separados. Esto proporciona un nivel de aislamiento sólido y eficiente.  Por otro lado, las VM emulan un hardware completo, incluyendo CPU, memoria y dispositivos de almacenamiento. Esto ofrece un aislamiento más estricto, ya que cada VM tiene su propio sistema operativo y recursos dedicados.

### Eficiencia de Recursos:

Contenedores: Al compartir el kernel, los contenedores son más ligeros y permiten ejecutar más instancias en un mismo hardware. Esto es ideal para entornos con muchos servicios y recursos limitados. Las VM requieren más recursos debido a la emulación del hardware. Esto limita el número de VM que se pueden ejecutar en un servidor.


### Tiempo de Arranque:

Los contenedores se inician en fracciones de segundo, lo que los hace ideales para entornos dinámicos donde se requiere escalar rápidamente los servicios y el proceso de inicialización de una VM implica cargar un sistema operativo completo, lo que puede tardar varios segundos o minutos.

### ¿Cuándo Usar Qué?

- Contenedores:
	La arquitectura de microservicios se beneficia enormemente de la portabilidad y escalabilidad de los contenedores también facilitan la automatización de los procesos de integración y despliegue continuo (CI/CD). Estps proporcionan entornos de desarrollo aislados y reproducibles. Los contenedores son la base de numerosas plataformas FaaS, que permiten ejecutar código de forma escalable y sin servidor.

- Máquinas Virtuales:
	Las aplicaciones legacy que requieren configuraciones específicas o sistemas operativos antiguos pueden ser más fácilmente migrables a una VM. Estas también ofrecen un mayor nivel de aislamiento, lo que las hace ideales para entornos altamente regulados o con requisitos de seguridad estrictos. Las aplicaciones que requieren grandes cantidades de recursos dedicados, como bases de datos o servidores de aplicaciones, pueden beneficiarse de las VM.


# Cuadro Materia


|   Materia   |            1            |            2            |            3            |            4            |            5            |            6            |            7            |            8            |
| :---------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: | :---------------------: |
|    Foro     | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
|  Respuesta  | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
| Laboratorio | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
|    Tarea    | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |
|    Extra    | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> | <input type="checkbox"> |



